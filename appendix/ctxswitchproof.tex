\section{Application of Extended Program Logic : Verifying a Simplified Version of Context Switch Routine}
\newcounter{lnum}
\setcounter{lnum}{1}
\newcommand{\llnum}{\thelnum\addtocounter{lnum}{1}}
\label{appendix:ctxswitchproof}

\begin{figure}[!h]
    \small
    \centering
    \[ 
        \begin{array}{lll}
            \multicolumn{3}{l}
                {
                    \quad \texttt{SwitchEntry}:
                    % \quad \lab{\texttt{switch}}: 
                } \\
            \\[-9pt]
            \llnum \quad \ \  
            & 
            \multicolumn{2}{l}
            {
                /* \text{codes save the \inRN{} and \localRN{}
                registers of current window into stack frame} */
            } \\
            % \llnum 
            % & \nop{} \\
            \llnum 
            & \sett & \TaskCur, \lreg{1} \\
            \llnum 
            & \ld & [\lreg{1}], \lreg{1} \\
            % \llnum 
            % & \cadd{} & \lreg{1}, \texttt{CONTEXT}\_\texttt{OFFSET}, \lreg{1} \\
            \llnum
            & \call{} & \texttt{reg}\_\texttt{save} \\
            \llnum
            & \nop{} \\
            \llnum
            & \mov{} & \regcwp, \greg{4} \\
            \llnum
            & \rd{} & \regwim, \greg{7} \\
            \llnum
            & \sett & 1, \greg{6} \\
            \llnum & \sll & \greg{6}, \greg{4}, \greg{4} \\
            \\[-5pt]
            \multicolumn{3}{l}
                {
                    \quad \texttt{Save}\_\texttt{Usedwindow}: 
                } \\
            \llnum & \sll & \greg{4}, 1, \greg{5} \\
            \llnum & \srl & \greg{4}, (\OSWINDOWs - 1), \greg{4} \\
            \llnum & \cor{} & \greg{4}, \greg{5}, \greg{4} \\
            \llnum & \andcc{} & \greg{4}, \greg{7}, \greg{0} \\
            \llnum & \bne & \texttt{Switch}\_\texttt{NewContext} \\
            \llnum & \nop{} \\
            \llnum & \crestore{} & \greg{0}, \greg{0}, \greg{0} \\
            \\[-9pt]
            \llnum & 
            \multicolumn{2}{l}
            {
                /* \text{codes save the \inRN{} and \localRN{}
                registers of current window into stack frame} */
            } \\
            \\[-9pt]
            % \call{} & \texttt{window}\_\texttt{save} \\
            \llnum & \nop{} \\
            \llnum & \jmp{} & \texttt{Save}\_\texttt{Usedwindow} \\
            \llnum & \nop{} \\
            \\[-5pt]
            \multicolumn{3}{l}
                {
                    \quad \texttt{Switch}\_\texttt{NewContext}: 
                } \\
            \llnum & \sett & \TaskCur, \lreg{0} \\
            \llnum & \sett & \TaskNew, \lreg{1} \\
            \llnum & \ld & [\lreg{1}], \lreg{1} \\
            \llnum & \st{} & \lreg{1}, [\lreg{0}] \\
            % \llnum & \cadd{} & \oreg{1}, \texttt{CONTEXT}\_\texttt{OFFSET}, \lreg{1} \\
            \llnum & \call{} & \texttt{reg}\_\texttt{restore} \\
            \llnum & \nop{} \\
            % \llnum & \call{} & \texttt{window}\_\texttt{restore} \\
            \\[-9pt]
            \llnum & 
            \multicolumn{2}{l}
            {
                /* \text{codes restore the \inRN{} and \localRN{}
                registers of current window from stack frame} */
            } \\
            \\[-9pt]
            \llnum & \nop{} \\
            \llnum & \retl{} \\
            \llnum & \nop{}
        \end{array}
    \]
    \caption{Main function of context switch routine}
    \label{fig:Main function of context switch routine}
\end{figure}

In this section, we give a simplified version of context switch routine in 
\Fig{\ref{fig:Main function of context switch routine}}. It reserves the 
main functionalities of the context switch routine introduced in 
\Sec{\ref{sec:ctxswitch}}, \eg saving the contexts of currrent thread 
and restoring the new one. We omit some details like judging whether the 
current thread is a valid thread. We give a simple introduction to the 
function shown in \Fig{\ref{fig:Main function of context switch routine}}, 
and show how to verify its correctness by applying our extended program 
logic for SPARCv8. 

\subsection{Simplified Context Switch Routine}

At the entrance of the context switch rountine shown in
\Fig{\ref{fig:Main function of context switch routine}}, we first 
% call an internal function \texttt{window}\_\texttt{save} to 
save the \localRN{} and \inRN{} registers into the stack in memory, 
and this part of code is shown in 
\Fig{\ref{fig:code for saving and restoring local and in}}(a). 
Then, as shown from line 2 to 6, we call the \texttt{reg}\_\texttt{save}  
to store the \outRN{} and \globalRN{} registers into the TCB 
of the current thread. As for the line 6 to 9, we get the identity of 
the current register window and the value of the \regwim{}. 
The block \SaveUsedWin{} (from line 12 to 22) saves the register windows 
(except the current one) into the stack of the current task in memory. 
It checks whether the previous window is valid. If it's valid, it 
uses the instruction $\crestore{}$ to set the previous window as the 
current one, and save its contents (\localRN{} and \inRN{} registers)
into stack in memory, then check the previous one continuously. 
The block \SwitchNewTask{} is responsible 
for restoring the context of the new task. From line 21 to 24, it 
sets the new task as the current one. Then, it calls function 
\texttt{reg}\_\texttt{restore} (at line 25)
to restore the $\outRN$ and $\globalRN$ 
registers from the new task's TCB, and restores the  
$\localRN$ and $\inRN$ registers from the new task's stack in memory. 
The code about restoring the $\localRN$ and $\inRN$ registers of 
the new task from memory is shown in 
\Fig{\ref{fig:code for saving and restoring local and in}}(b). 
The implementations of internal functions
\texttt{reg}\_\texttt{save} and \texttt{reg}\_\texttt{restore} 
are omitted here because these two functions are taken 
from the OS kernal we verified and we can't show these part 
of codes according to confidentiality agreement, but we show 
their specifications in \Fig{\ref{fig:Specifications of Internal Functions}}.

\subsection{Specification of the Simplified Context Switch Routine}

First, we define the abstract assembly primitive $\primsw$, which is 
already introduced in the \Sec{\ref{subsec:High-level Pseudo-SPARCv8 Language}}. 
{
    \small
    $$
    \begin{array}{lcl}
        \primsw & \define & 
        \lambda \, \args{\val}, \hpstate, \hpstate'. \ 
        \exists \, \thrdid'. \ 
        \Mem(\TaskNew) = (\thrdid', 0) \, \land \, 
        \thrdpool(\thrdid') = 
            (\hRstate', \pc', \npc') \\ 
        & & \hspace*{8em} \land \, 
        \thrdpool' = \thrdpool\{ \thrdid \rightsquigarrow 
        (\hRstate, \pc, \npc) \}
        \, \land \, \thrdid \neq \thrdid'
        \, \land \, \args{\val} = \nil \\
        \\[-8pt] 
        \multicolumn{3}{l}
        {
        	\hspace*{1.8em}
            \text{where } \, 
            \hpstate = 
                (\thrdpool, \thrdid, (\hRstate, \pc, \npc), \Mem), \, 
            \tid \in \dom(\thrdpool), \,
            \hpstate' = 
            (\thrdpool', \thrdid', 
            	(\hRstate', \lab{} + 8, \lab{} + 12), \Mem), \lab{} = \hRstate'.\hRfile(\reg{15}). 
%            \lab{} = \hRstate'.\hRfile(\reg{15}). 
            % \,
            % \AftExt(\hRstate, \pc, \npc) \define 
            % (\hRstate, \hRstate.\hRfile(\reg{15}) + 8, 
            %     \hRstate.\hRfile(\reg{15}) + 12)
        }
    \end{array}
    $$
}
Then we show the specification of the simplified context switch routine below, and some auxiliary 
definitions used in specification can be found in \Fig{\ref{def:aux-def-spec}}: 
{
    \small
    \[
        \begin{array}{lcl}
            \Apre(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, \hthrdlocalst_n) 
            & \define & 
            \Env{\env} \sepstar
            (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n) \sepstar 
            \metricAst{10} \sepstar \\
            & & \quad 
            \RelCurT{\thrdid_c}{\notCare}{\env}{\hthrdlocalst_c} \sepstar 
            \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
            \safePrimAst{\, \primsw(\nil) \,} \\
            \\[-5pt]
            \Apost(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, \hthrdlocalst_n)
            & \define & \exists \, \env', \hthrdlocalst'. \, \Env{\env'} 
            \sepstar (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n) 
            \sepstar \\
            & & 
            \quad 
            \RelCurT{\thrdid_n}{\nst}{\env'}{\hthrdlocalst'} \sepstar 
            \RelRdyT{\thrdid_c}{\pEnv{\env}}{\hthrdlocalst_c} \sepstar 
            \safePrimAst{\, \primdone \,}  
        \end{array}
    \]
} 

\begin{figure}[!t]
    \centering
    \vspace*{-0.5em}
    \small
    \[
        \begin{array}{l}
            \hspace*{-0.15em}
            \begin{array}{lcl}
                \RelStkFm{\block}{\fm_1}{\fm_2} & \define & 
                (\relmsto{(\block, 0)}{\fm_1[0]}) \sepstar \dots \sepstar 
                (\relmsto{(\block, 28)}{\fm_1[7]}) \\
                & & \quad \sepstar 
                (\relmsto{(\block, 32)}{\fm_2[0]}) \sepstar 
                \dots \sepstar
                (\relmsto{(\block, 60)}{\fm_2[7]})
            \end{array} \\
            \\[-5pt]
            \hspace*{-0.15em}
            \begin{array}{lcl}
                \RelStk{\block}{\Wstack}{\hWstk} & \define & 
                \left\{
                    \begin{array}{ll}
                        \RelStkFm{\block}{\notCare}{\notCare} \sepstar
                        \RelStk{\block'}{\Wstack'}{\hWstk'} & 
                            \quad \cif \  
                            \fm_2[6] = (\block', 0), \, \Wstack = \fm_1 \stCons \fm_2 \stCons \Wstack' \\
                            & \quad \ \ \hWstk = (\block, \fm_1, \fm_2) \stCons \hWstk' \\
                            \\[-8pt]
                        \RelStkFm{\block}{\fm_1}{\fm_2} \sepstar 
                        \RelStk{\block'}{\Wstack'}{\hWstk'} & 
                            \quad \cif \ 
                            \fm_2[6] = (\block', 0), \, \Wstack = \nil \\
                            & \quad \ \ \hWstk = (\block, \fm_1, \fm_2) \stCons \hWstk' \\
                            \\[-8pt]
                        \empAst & \quad \cif \ \Wstack = \nil, \hWstk = \nil \\
                            \\[-8pt]
                        \afalse & \quad \otherwise
                    \end{array}
                \right. 
            \end{array} \\
            \\[-5pt]
            \rRegs \ \define \ \regst{\asr_0}{\notCare} \sepstar \dots 
                        \regst{\asr_{31}}{\notCare} \sepstar \regst{\regY}{\notCare} \\
            \\[-5pt]
            \LRegs{\RFile} \ \define \ \regst{\globalRN}{\RFile(\globalRN)} \sepstar 
            \regst{\outRN}{\RFile(\outRN)} \sepstar \regst{\localRN}{\RFile(\localRN)} 
            \sepstar \regst{\inRN}{\RFile(\inRN)} \sepstar \\
            \hspace*{7em} \regst{\regn}{\RFile(\regn)} \sepstar 
            \regst{\regz}{\RFile(\regz)} \sepstar \regst{\regc}{\RFile(\regz)} 
            \sepstar \regst{\regv}{\RFile(\regv)} \sepstar \rRegs
            \\
            \\[-5pt]
            % \HRegs{\hRfile} \ \define \ \hregsto{\globalRN}{\hRfile(\globalRN)} \sepstar
            % \hregsto{\outRN}{\RFile(\outRN)} \sepstar \hregsto{\localRN}{\hRfile(\localRN)} 
            % \sepstar \hregsto{\inRN}{\hRfile(\inRN)} \\
            % \hspace*{7em} \hregsto{\regn}{\hRfile(\regn)} \sepstar 
            % \hregsto{\regz}{\hRfile(\regz)} \sepstar \hregsto{\regc}{\hRfile(\regz)} 
            % \sepstar \hregsto{\regv}{\hRfile(\regv)} \\
            % \\[-5pt]
            \wfwin{\RFile}{\Wstack} \ \define \ 
            (\stackAstP{\RFile(\regcwp)}{\Wstack} \sepstar 
                \regst{\regwim}{\RFile(\regwim)}) 
            \, \land \, \ctxfm(\RFile, \Wstack)
            \\
            \\[-5pt]
            \hspace*{-0.15em}
            \begin{array}{lll}
                \relcontext{\thrdid}{\block}{\nst} & \define & 
                (\relmsto{(\thrdid, \ofsGOne)}{\nst(\greg{0})}) 
                \sepstar \, \dots \, \sepstar
                (\relmsto{(\thrdid, \ofsGEig)}{\nst(\greg{7})}) \\
                & & 
                \sepstar
                (\relmsto{(\thrdid, \ofsOOne)}{\nst(\oreg{0})}) 
                \sepstar \, \dots \, \sepstar
                (\relmsto{(\thrdid, \ofsOEig)}{\nst(\oreg{7})}) \\
                & & 
                \sepstar 
                (\relmsto{(\thrdid, \ofsN)}{\nst(\regn)}) \sepstar \, \dots 
                \sepstar (\relmsto{(\thrdid, \ofsV)}{\nst(\regv)}) \\
                & & 
                \sepstar \RelStkFm{\block}{\nst[\localRN]}{\nst[\inRN]}
                % \sepstar
                % (\relmsto{(\block, 0)}{\nst(\lreg{0})}) 
                % \sepstar \, \dots \, \sepstar
                % (\relmsto{(\block, 28)}{\nst(\lreg{7})}) 
                % \\
                % & & 
                % \sepstar
                % (\relmsto{(\block, 32)}{\nst(\ireg{0})}) 
                % \sepstar \, \dots \, \sepstar
                % (\relmsto{(\block, 60)}{\nst(\ireg{7})})
            \end{array}
            \\
            \\
            \Env{\env} \ \define \ 
                \LRegs{\RFile} \sepstar 
                % \HRegs{\hRfile} \sepstar 
                \wfwin{\RFile}{\Wstack} \qquad \qquad 
                \text{where} \ \env = (\RFile, \Wstack)
                \\
            %     \\[-9pt]
            % \qquad\qquad 
            % \text{where} \ \env = (\RFile, \Wstack), \, 
            % \hthrdlocalst = ((\hRfile, \block, \hWstk), \pc, \npc) \\
            \\[-5pt]
            \hspace*{-0.15em}
            \begin{array}{lll}
                \RelCurTAux{\thrdid_c}{\nst}{\env}{\hthrdlocalst} & \define &
                (\relcontext{\thrdid_c}{\block}{\nst} \sepstar 
                \RelStk{\block'}{\Wstack}{\hWstk} \sepstar (\astCurCont{\thrdid_c}{\hthrdlocalst})) \\
                & & \, \land \,  \RFile(\spreg) = (\block, 0) \, \land \, 
                \Rinj{\RFile}{\hRfile}
                % ((\relmsto{\TaskCur}{\thrdid_c}) \sepstar 
                % (\relcontext{\thrdid_n}{\block}{\nst} \, \land \, \RFile(\spreg) = (\block, 0)) \sepstar \\
                % & & \RelStk{\block'}{\Wstack}{\hWstk} \sepstar (\astCurCont{\thrdid_c}{\hthrdlocalst}))
                % \, \land \, (\Rinj{\RFile}{\hRfile}) 
            \end{array}
            \\
            \\[-9pt]
            \qquad\qquad
            \text{where} \ \env = (\RFile, \Wstack), \, 
            \hthrdlocalst = ((\hRfile, \block, \hWstk), \pc, \npc), 
            \, \RFile(\fpreg) = (\block', 0), \nst \in \text{RegFile} \\
            \\[-5pt]
            \RelCurT{\thrdid_c}{\nst}{\env}{\hthrdlocalst} \define 
            (\relmsto{\TaskCur}{(\thrdid_c, 0)}) \sepstar 
            \RelCurTAux{\thrdid_c}{\nst}{\env}{\hthrdlocalst} \\
            \\[-5pt]
            \hspace*{-0.15em}
            \begin{array}{lll}
                \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst} & \define & 
                (\relcontext{\thrdid_n}{\block}{\nst}
                \sepstar 
                \RelStk{\block'}{\nil}{\hWstk} \sepstar 
                (\astRdyCont{\thrdid_n}{\hthrdlocalst})) \\
                & &  
                \, \land \, 
                \Rinj{\nst}{\hRfile} \, \land \, \RFile(\spreg) = (\block, 0)
            \end{array}  \\
            \\[-9pt]
            \qquad\qquad
            \text{where} \ \hthrdlocalst = ((\hRfile, \block, \hWstk), \pc, \npc), 
            \, \nst(\fpreg) = (\block', 0), \, \nst \in \text{RegFile} \\
            \\[-5pt]
            \pEnv{\env} \ \define \ \RFile \qquad \ \ \text{where} \ \env = (\RFile, \Wstack)
            \qquad\qquad
            \relmsto{\loc}{\val} \ \define \ 
            \msto{\loc}{\val} \sepstar \hmsto{\loc}{\val} 
        \end{array}
    \]
    \caption{Auxiliary Definitions for Specification}
    \label{def:aux-def-spec}
\end{figure}

Note that the execution of context switch routine will 
call function \texttt{reg\_save}, \texttt{reg\_restore}, and  
\texttt{window\_restore} once, and call function  
and jump to block \texttt{save\_usedwindow} no more than 8 times separately, 
because the number of the register windows is 8. So, assigning 10 tokens 
to the precondition of the context switch routine is enough. 
According to the logic rules of extended program logic shown 
in \Fig{\ref{fig:Selected Inference Rules for Refinement Verification}}, 
we need to check whether the specification of context switch rountine 
is well-defined. 

\begin{lemma}
    \em
    \label{lemma:wdspec}
    $\wdSpec{\Apre}{\Apost}{\primsw}$. 
\end{lemma}
\begin{proof}
    We unfold $\wdSpec{\Apre}{\Apost}{\primsw}$ by \Def{\ref{def:well-defined specification}}, 
    and we need to prove three properities about the specification and 
    abstract assembly primitive $\primsw$. 
    \begin{enumerate}
        \item 
        for any $\args{\val}, \hpstate, \hpstate', \hpstate_r$. 
            if $\primsw(\args{\val})(\hpstate)(\hpstate')$, and 
            $\hpstate \perp \hpstate_r$, 
            then the following holds : 
            \begin{itemize}
                \item $\hpstate'.\hthrdlocalst.\pc = \lab{} + 8$, 
                    $\hpstate'.\hthrdlocalst.\npc = \lab{} + 12$
                    (where $\hpstate'.\hthrdlocalst.\hRstate.\hRfile
                        ({\color{red} \reg{15}}) = \lab{}$);
                \item there exists $\hpstate'', \hpstate_r'$, 
                    $\primsw(\args{\val})(\hpstate \uplus \hpstate_r) 
                        (\hpstate'')$, $\hpstate'' = \hpstate' \uplus \hpstate_r'$, 
                    and $\hpstate_r.\thrdpool = \hpstate_r'.\thrdpool$, 
                    $\hpstate_r.\Mem = \hpstate_r'.\Mem$; 
            \end{itemize}
        \vspace*{0.3em}
        The correctness proof of this property can be achieved directly from the definition 
        of the $\primsw$. The definition of the $\primsw$ requires that 
        the program counters $\pc$ and $\npc$ are equal to 
        $\lab{}\!+\!8$ and $\lab{}\!+\!12$, where $\lab{}$ is 
        contained in $\reg{15}$ register after the execution of 
        $\primsw$. The execution of $\primsw$ only accesses 
        the current thread $\tid$ and new $\tid'$ (stored in $\TaskNew$ in memory) 
        in thread pool and the location $\TaskNew$ in memory. 
        So the threads and memory described in $\hpstate_r$ 
        remains unchanged.

        We prove the correctness of this property formally 
        below. We unfold $\primsw(\args{\val})(\hpstate)(\hpstate')$ 
        and $\hpstate\perp\hpstate_r$ according to their definitions 
        and get the following hold: 
        (let $\hpstate = (\thrdpool, \tid, (\hRstate, \pc, \npc), \mem)$ and 
        $\hpstate_r = (\thrdpool_r, \tid_r, \hthrdlocalst_r, \mem_r)$)
        \begin{align}
            & \mem(\TaskNew) = (\tid', 0) \\
            & \thrdpool(\tid') = (\hRstate', \pc', \npc') \\
            & \thrdpool' = \thrdpool\{ \tid \leadsto \{ \hRstate, \pc, \npc \} \}, \,
                \tid \in \dom(\thrdpool) \\
            & \tid \neq \tid', \, \args{\val} = \nil \\
            & \hpstate' = (\thrdpool', \tid', (\hRstate', \lab{}\!+\!8, \lab{}\!+\!12), 
                \mem{}), \lab{} = \hRstate'.\hRfile(\reg{15}) \\
            & \notag \\
            & \thrdpool \perp \thrdpool_r, \, \mem \perp \mem_r \\
            & \tid_r = \tid, \, \hthrdlocalst_r = (\hRstate, \pc, \npc)
        \end{align}
        We can prove that there exists 
        $\hpstate'' = (\thrdpool'\uplus\thrdpool_r, \tid', 
            (\hRstate', \lab{}\!+\!8, \lab{}\!+\!12), \mem\uplus\mem_r)$, 
        and 
        $\hpstate_r' = (\thrdpool_r, \tid', 
            (\hRstate', \lab{}\!+\!8, \lab{}\!+\!12), \mem_r)$, 
        such that 
        $\primsw(\args{\val})(\hpstate \uplus \hpstate_r)(\hpstate'')$,
        $\hpstate'' = \hpstate' \uplus \hpstate_r'$, 
        and $\hpstate_r.\thrdpool = \hpstate_r'.\thrdpool$, 
        $\hpstate_r.\Mem = \hpstate_r'.\Mem$.
        \vspace*{0.5em}
        
        \item for any $\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, \hthrdlocalst_n$,
            \begin{itemize}
                \item $\Apre(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, \hthrdlocalst_n) 
                    \Longrightarrow \safePrimAst{\primsw} \sepstar \atrue$; 
                \item $\Apost(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, \hthrdlocalst_n) 
                    \Longrightarrow \safePrimAst{\primdone} \sepstar \atrue$; 
            \end{itemize}   
        \vspace*{0.3em}
        According the definition of $\Apre$ and $\Apost$, 
        this property's proof is trivial.
        \vspace*{0.5em}
        
        \item for any $\args{\val}, \state, \hpstate$, 
        if $(\state, \hpstate, \notCare, \notCare) \in 
            \INV{(\primsw(\args{\val}), \args{\val})}$, 
        then there exists $\thrdid_c, \thrdid_n, \env$, $\nst, 
        \hthrdlocalst_c, \hthrdlocalst_n, \relastP_r$ and $\word$, 
        such that:
        \begin{itemize}
            \item $\asrtmodel{(\state, \hpstate, \primsw(\args{\val}), \word)}
                {\Apre(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, 
                \hthrdlocalst_n) \sepstar \relastP_r}$; 
            \item  $\Apost(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, 
                \hthrdlocalst_n) \sepstar \relastP_r \Longrightarrow 
                \INV{(\primdone, \notCare)}$; 
            \item $\Sta(\primsw(\args{\val}), \relastP_r)$. 
        \end{itemize}
        \vspace*{0.3em}
        The key to prove this case is to find $\thrdid_c$, $\thrdid_n$, $\env$, 
        $\nst$, $\hthrdlocalst_c$, $\hthrdlocalst_n$, $\relastP_r$ and $\word$. 
        Because we have $(\state, \hpstate, \notCare, \notCare) \in 
            \INV{(\primsw(\args{\val}), \args{\val})}$, we can know that there exists 
        a ready thread $\thrdid'$, a prefix of the frame list $\Wstack'$ 
        and a register state $\Rstate'$, where 
        $\hpstate.\thrdpool(\thrdid') = \hthrdlocalst'$, 
        $\thrdid \neq \thrdid'$, $\hpstate.\Mem(\TaskNew) = (\thrdid', 0)$, 
        $\ctxfm(\state.\Rstate) = \Wstack'$ 
        and $\restoreCtx{\state.\Mem}{\thrdid'}{\Rstate'}$ hold. 
        And we require $\thrdid_c = \hpstate.\thrdid$, $\thrdid_n = \thrdid'$, 
        $\env = (\state.\Rstate.\RFile, \Wstack')$, $\nst = \Rstate'.\RFile$, $\word = 10$, 
        and $\relastP_r = \exists \, \Mem, \thrdpool. \, \MemRAsrt{\Mem}
        \sepstar \RdyTsRAsrt{\thrdpool}$. Then, we can finish 
        the proof. 

        \begin{figure}[!t]
            \centering
            \[
                \begin{array}{lcl}
                    \centering
                    \MemRAsrt{\Mem} & \define & 
                    \left\{
                        \begin{array}{ll}
                            \empAst & \quad \cif \ \Mem = \emptyset \\
                            \\[-9pt]
                            (\relmsto{\loc}{\val}) \sepstar (\hmsto{\loc}{\val}) 
                            & \quad \cif \ \Mem = \{ \loc \rightsquigarrow \val \} \\
                            \\[-9pt]
                            \exists \, \Mem_1, \Mem_2. \,
                            \MemRAsrt{\Mem_1} \sepstar \MemRAsrt{\Mem_2}
                            & \quad \otherwise
                        \end{array}
                    \right. \\
                    \\[-8pt]
                    \RdyTsRAsrt{\thrdpool} & \define & 
                    \left\{
                        \begin{array}{ll}
                            \empAst & \quad \cif \ \thrdpool = \emptyset \\
                            \\[-9pt]
                            \RelRdyT{\thrdid}{\notCare}{\hthrdlocalst} & 
                            \quad \cif \ \thrdpool = \{ \thrdid \rightsquigarrow \hthrdlocalst \} \\
                            \\[-9pt]
                            \exists \, \thrdpool_1, \thrdpool_2. \, 
                            \RdyTsRAsrt{\thrdpool_1} \sepstar \RdyTsRAsrt{\thrdpool_2} & 
                            \quad \otherwise 
                        \end{array}
                    \right. \\
                    \\[-5pt]
                    \restoreCtx{\Mem}{\thrdid}{(\RFile, \Wstack)} & \define & 
                    \exists \, \block. \, 
                    \RFile(\greg{0}) = \Mem(\thrdid, \ofsGOne) \, \land \, \dots \, \land \, 
                    \RFile(\greg{7}) = \Mem(\thrdid, \ofsGEig) \\
                    & & \, \land \, 
                    \RFile(\oreg{0}) = \Mem(\thrdid, \ofsOOne) \, \land \, \dots \, \land \, 
                    \RFile(\oreg{7}) = \Mem(\thrdid, \ofsOEig)  \\
                    & & \, \land \, 
                    \RFile(\regn) = \Mem(\thrdid, \ofsN) \, \land \, \dots \, \land \, 
                    \RFile(\regv) = \Mem(\thrdid, \ofsV) \\
                    & & \, \land \, 
                    \RFile(\lreg{0}) = \Mem(\block, 0) \, \land \, \dots \, \land \, 
                    \RFile(\lreg{7}) = \Mem(\block, 28) \\
                    & & \, \land \, 
                    \RFile(\ireg{0}) = \Mem(\block, 32) \, \land \, \dots \, \land \, 
                    \RFile(\ireg{7}) = \Mem(\block, 60) \, \land \, 
                    \RFile(\spreg) = (\block, 0) \\
                    & & \, \land \, 
                    (\exists \, \cwp, n. \, \RFile(\regcwp) = \cwp \, \land \, 
                    \RFile(\regwim) = 2^n \, \land \, \prevcwp{(\cwp)} = n)  
                \end{array}
            \]
            \caption{Auxiliary Definitions About Frame Assertion}
        \end{figure}

        We prove the correctness of this property formally
        below. We first unfold 
        $(\state, \hpstate, \notCare, \notCare) \in \INV{(\primsw(\args{\val}), \val)}$
        and get the following holds:
        \begin{align}
            & \stateRel{\state}{\hpstate} \label{a:ctxswitch-staterel} \\
            & \exists \, \hpstate'. \, 
                \primMultiTrans{(\primsw(\args{\val}), \hpstate)}
                    {*}{(\primdone, \hpstate')} \label{a:ctxswitch-swtrans} \\
            & \arguments(\hpstate.\hthrdlocalst.\hRstate, \hpstate.\Mem, \args{\val})
        \end{align}

        Let $\hpstate = (\thrdpool, \tid, (\hRstate, \pc, \npc), \Mem')$, 
        $\state = (\Mem, \Rstate, \DBuf)$. We first unfold 
        $\stateRel{\state}{\hpstate}$ (\ref{a:ctxswitch-staterel})
        according to its definition. 
        \begin{align}
            & \mem = \mem_c \uplus \mem_T
                \uplus \{ \TaskCur \leadsto (\tid, 0) \}
                \uplus \mem' \\
            & \curStRel{(\mem_c, \Rstate)}
                {(\tid, (\hRstate, \pc, \npc))} \\
            & \rdyStRel{\mem_T}{\thrdpool\backslash\{\tid\}}
                \label{a:ctxswitch-rdyrel} \\
            & \DBuf = \nil
        \end{align}

        We unfold the execution of $\primsw{}$ (\ref{a:ctxswitch-swtrans})
        and get that there exists $\tid'$, such that: 
        \begin{align}
            & \mem'(\TaskNew) = (\tid', 0) \\
            & \thrdpool(\tid') = (\hRstate', \pc', \npc') \label{a:ctxswitch-newtsk} \\
            & \thrdpool' = \thrdpool\{ \tid \leadsto \{ \hRstate, \pc, \npc \} \}, \,
                \tid \in \dom(\thrdpool) \\
            & \tid \neq \tid', \, \args{\val} = \nil \label{a:ctxswitch-newtsk-not-curt} \\
            & \hpstate' = (\thrdpool', \tid', (\hRstate', \lab{}\!+\!8, \lab{}\!+\!12), 
                \mem{}), \lab{} = \hRstate'.\hRfile(\reg{15}) 
        \end{align} 
    \end{enumerate} 

    From (\ref{a:ctxswitch-newtsk-not-curt}) and 
    (\ref{a:ctxswitch-rdyrel}), we know that $\tid' \in \dom(\thrdpool\backslash\{\tid\})$ 
    and we can split $\mem_T$ as two parts: 
    $\mem_{\tid'}$ storing the contexts of the new task $\tid'$, 
    and $\mem_T'$ storing the contexts of the rest of the ready threads. 
    \begin{align}
        & \mem_T = \mem_{\tid'}\uplus\mem_{T}' \\
        & \restoreCtx{\mem_{\tid'}}{\tid'}{\Rstate'} \\
        & \curStRel{(\mem_{\tid'}, \Rstate')}
            {(\tid', (\hRstate', \pc', \npc'))} \\
        & \rdyStRel{\mem_T'}{\thrdpool\backslash\{\tid, \tid'\}}
    \end{align}

    Then, we can prove that there exists 
    $\tid_c = \tid$, $\tid_n = \tid'$, 
    $\env = (\Rstate.\RFile, \Wstack')$ \, 
    (where \ $\Wstack' = \ctxfm(\Rstate)$), 
    $\nst = \hRstate'.\RFile$, $\word = 10$, 
    $\hthrdlocalst_c = (\hRstate, \pc, \npc)$, 
    $\hthrdlocalst_n = (\hRstate', \pc', \npc')$ 
    and $\relastP_r = \exists \, \Mem, \thrdpool. \, \MemRAsrt{\Mem}
    \sepstar \RdyTsRAsrt{\thrdpool} \sepstar \rRegs$, 
    such that
    \begin{itemize}
        \item $\asrtmodel{(\state, \hpstate, \primsw(\nil), \word)}
            {\Apre(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, 
            \hthrdlocalst_n) \sepstar \relastP_r}$ holds, because 
            we can prove that there exists $\state_1$, $\state_2$, 
            $\hpstate_1$ and $\hpstate_2$, such that: 
            \begin{align}
                & \state = \state_1 \uplus \state_2 \\
                & \hpstate = \hpstate_1 \uplus \hpstate_2 \\
                & \state_1 = (\mem_c\uplus\mem_{\tid'}\uplus
                    \{ \TaskCur \leadsto (\tid, 0), 
                       \TaskNew \leadsto (\tid', 0) \}, 
                    \Rstate, \nil) \\
                & \state_2 = (\mem_T'\uplus(\mem'\backslash\{\TaskNew\}), 
                    (\emptyset, \Rstate.\Wstack), \nil) \\
                & \hpstate_1 = (\{ \tid \leadsto \thrdpool(\tid), 
                    \tid' \leadsto (\hRstate', \pc', \npc') \}, 
                    \tid, (\hRstate, \pc, \npc), 
                    \{ \TaskNew \leadsto (\tid', 0) \}) \\
                & \hpstate_2 = (\thrdpool\backslash\{ \tid, \tid' \}, 
                    \tid, (\hRstate, \pc, \npc), \mem'\backslash\{\TaskNew\}) \\
                & \asrtmodel{(\state_1, \hpstate_1, \primsw(\nil), \word)}
                    {\Apre(\tid_c, \tid_n, \env, \nst, \hthrdlocalst_c, 
                        \hthrdlocalst_n)} \\
                & \asrtmodel{(\state_2, \hpstate_2, \primsw(\nil), \word)}
                    {\relastP_r} 
            \end{align}

        \item $\Apost(\thrdid_c, \thrdid_n, \env, \nst, \hthrdlocalst_c, 
            \hthrdlocalst_n) \sepstar \relastP_r \Longrightarrow 
            \INV{(\primdone, \notCare)}$. \\
            Supposing 
            $\asrtmodel{(\state', \hpstate', \primcom, \word)}
                {\Apost(\tid_c, \tid_n, \env, \nst, \hthrdlocalst_c, 
                    \hthrdlocalst_n) \sepstar \relastP_r}$, we 
            get there exists $\state_1'$, $\state_2'$, $\hpstate_1'$ 
            and $\hpstate_2'$, such that: 
            \begin{align}
                & \state' = \state_1' \uplus \state_2' \\
                & \hpstate' = \hpstate_1' \uplus \hpstate_2' \\
                & \asrtmodel{(\state_1', \hpstate_1', \primcom, \word)}
                    {\Apost(\tid_c, \tid_n, \env, \nst, \hthrdlocalst_c, 
                        \hthrdlocalst_n)} \\
                & \asrtmodel{(\state_2', \hpstate_2', \primcom, \word)}
                    {\relastP_r}
            \end{align}

            Then, according to the definition of $\apost$, 
            we get there exists $\mem_n'$, $\mem_c'$, 
            $\Rstate_c'$, $\Rstate'$, $\hthrdlocalst_n'$ 
            and $\hthrdlocalst'$, such that:
            \begin{align}
                & \state_1' = 
                (\mem_n'\uplus\mem_{\tid}'\uplus
                    \{ \TaskCur \leadsto (\tid_n, 0), 
                    \TaskNew \leadsto (\tid_n, 0) \}, 
                \Rstate', \nil) \\
                & \hpstate_1' = 
                (\{ \tid_n \leadsto \hthrdlocalst_n', 
                    \tid_c \leadsto \hthrdlocalst_c \}, \tid_n, 
                \hthrdlocalst', \{ \TaskNew \leadsto (\tid_n, 0) \}) 
                \\
                & \curStRel{(\mem_n', \Rstate_n')}{(\tid_n, \hthrdlocalst')}
                \\
                & \restoreCtx{\mem_c'}{\tid_c}{\Rstate_c'}, \, 
                \curStRel{(\mem_c', \Rstate_c')}{(\tid_c, \hthrdlocalst_c)} \\
                & \primcom = \primdone
            \end{align}
            And according to the definition of $\relastP_r$, we get 
            there exists $\mem_{\thrdpool_r}'$, $\mem_r'$ and 
            $\thrdpool_r'$ such that:
            \begin{align}
                & \state_2' = (\mem_{\thrdpool_r}' \uplus \mem_r', 
                    (\nil, \Rstate'.\Wstack), \nil) \\
                & \hpstate_2' = (\thrdpool_r', \tid_n, \hthrdlocalst', \mem_r') \\
                & \rdyStRel{\mem_{\thrdpool_r}'}{\thrdpool_r'}
            \end{align}  
            Then, we get the following hold:
            \begin{align}
                & \state.\mem = 
                \mem_n'\uplus(\mem_c'\uplus\mem_{\thrdpool_r}')\uplus
                \{ \TaskCur \leadsto (\tid_n, 0), 
                \TaskNew \leadsto (\tid_n, 0) \} \uplus
                \mem_r' \\
                & \curStRel{(\mem_n', \Rstate_n')}{(\tid_n, \hthrdlocalst')} \\
                & \rdyStRel{\mem_c'\uplus\mem_{\thrdpool_r}'}
                    {\{ \tid_c \leadsto \hthrdlocalst_c \}\uplus\thrdpool_r'}
            \end{align}
            Thus, we get $\stateRel{\state'}{\hpstate'}$, and 
            $\INV{(\primdone, \notCare)}$ holds. 
    \end{itemize}
\end{proof}

We use $\code_{\texttt{switch}}$ to represent the 
code heap that stores the code of context switch rountine shown 
in \Fig{\ref{fig:Main function of context switch routine}}. 
The specifications of the internal function can be found in 
\Fig{\ref{fig:Specifications of Internal Functions}}. The 
function \texttt{reg\_save} is responsible for saving the 
\localRN{}, \inRN{} and integer condition code fields $\regn$, 
$\regz$, $\regc$ and $\regv$ registers into TCB in memory. 
And the function \texttt{reg\_restore} does the reverse of 
\texttt{reg\_save}, restoring \localRN{}, \inRN{} and integer 
condition code fields registers from the TCB in memory. 
The specification of code block 
\SaveUsedWin{} is a little complicated. 
We can find its implementation is a loop, which checks whether the 
previous window is valid and saving the contents of the valid 
previous window until the previous one is invalid. 
We need to define the loop invariant $I$ here.

\begin{figure}[!t]
    \centering
    \[
        \small
        \begin{array}{l}
            \textit{Loop invariant I}: \\
            \\[-9pt] \ \ 
            \wptr(\RFile_0) \define 
            (\RFile_0(\greg{7}) = \RFile_0(\regwim)) \, \land \, \\
            \hspace*{6em} 
            ((\RFile_0(\greg{4}) = (1 <\!\!< \RFile_0(\regcwp))) \, \lor \, 
                (\RFile_0(\greg{4}) = ((1 <\!\!< \RFile_0(\regcwp)) <\!\!< 8))) \\
            \\[-5pt] \ \ 
            \linkF((\block_1, \hWstk_1), (\block_2, \hWstk_2), \hWstk) \define 
            \hWstk_1 \lstApp \hWstk_2 = \hWstk \, \land \, 
            (\hWstk_1 = \nil \rightarrow \block_1 = \block_2) \\
            \hspace*{10em}
            (\forall \, \block, \fm_1, \fm_2, \hWstk'. \, 
                \hWstk_1 = (\block, \fm_1, \fm_2) \stCons \hWstk' \rightarrow
                \fm_2[6] = (\block_2, 0)
            )
            \\
            \\[-5pt]
            \begin{array}{lcl} \ 
                I(\thrdid_c, \RFile, \hthrdlocalst_c) & \define & 
                \exists \, \RFile_0, \Wstack_0. \, 
                (\Env{\RFile_0, \Wstack_0} \, \land \, 
                \wptr(\RFile_0)) \sepstar 
                \metricAst{|\Wstack_0| + 2} \\
                & & 
                \sepstar
                (
                (
                    \relmsto{\TaskCur}{(\thrdid_c, 0)} \sepstar 
                    \relcontext{\thrdid_c}{\block}{\RFile} \sepstar 
                    \astCurCont{\thrdid_c}{\hthrdlocalst_c}
                ) 
                \, \land \, \Rinj{\RFile}{\hRfile}) \\
                % \, \land \, 
                % \RFile(\spreg) = (\block, 0) \, \land \, \RFile(\fpreg) = (\block', 0)
                & & \sepstar
                (
                    \exists \, \block'', \hWstk_1, \hWstk_2. \, 
                    (\RelStk{\block'}{\nil}{\hWstk_1} \sepstar 
                        \RelStk{\block''}{\Wstack_0}{\hWstk_2}) \,
                    \land \, 
                    \RFile_0(\spreg) = (\block'', 0) \\
                    & & \quad
                    \, \land \, 
                    \linkF((\block', \hWstk_1), (\block'', \hWstk_2), \hWstk)
                ) \\
                \\[-9pt]
                \multicolumn{3}{l}
                {
                    \qquad 
                    \text{where} \ 
                    \hthrdlocalst_c = (\hRfile, \block, \hWstk), \, 
                    \RFile(\spreg) = (\block, 0), \text{and } 
                    \RFile(\fpreg) = (\block', 0)
                }
            \end{array} 
            \\
            \\
            \texttt{reg\_save}: \ (\lgvl = (\thrdid, \hthrdlocalst, \RFile, \Wstack, 
            \primcom, \nst)) \\
            \\[-9pt]
            \quad 
            \relspecpre_{\textit{rs}} \ \lgvl \define 
            \Env{\RFile, \Wstack} \sepstar 
            \context{\thrdid, \block, \nst} \sepstar 
            (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar \safePrimAst{\primcom} \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{rs}} \ \lgvl \define 
            (\exists \, \nst'. \, \Env{\RFile, \Wstack} \sepstar
            \relcontext{\thrdid}{\block}{\nst'}) \sepstar 
            (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar \safePrimAst{\primcom} \\
            \hspace*{5em}
            \, \land \, 
            \nst' = \nst\{ \globalRN \rightsquigarrow \RFile(\globalRN), 
                \outRN \rightsquigarrow \RFile(\outRN), 
                \regn \rightsquigarrow \RFile(\regn), \dots, 
                \regv \rightsquigarrow \RFile(\regv) \}  \\
            \\[-5pt]
            \texttt{reg\_restore}: \ (\lgvl = (\thrdid, \hthrdlocalst, \RFile, \Wstack, 
                \block, \nst)) \\
            \\[-9pt]
            \quad
            \relspecpre_{\textit{rr}} \ \lgvl \define \Env{\RFile, \Wstack} \sepstar 
            \relcontext{\thrdid}{\block}{\nst} \sepstar 
            (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar \safePrimAst{\primcom} \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{rr}} \ \lgvl \define \exists \, \RFile'. \,  (\Env{\RFile', \Wstack}
            \sepstar \relcontext{\thrdid}{\block}{\nst} \sepstar 
            (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar \safePrimAst{\primcom} \\
            \hspace*{5em}
            \, \land \, 
            \RFile' = \RFile\{ \globalRN \rightsquigarrow \nst(\globalRN), 
                \outRN \rightsquigarrow \nst(\outRN), \regn \rightsquigarrow \nst(\regn), 
                \dots, \regv \rightsquigarrow \nst(\regv) \} \\
            \\[-5pt]
            \SaveUsedWin{}: \ 
            (\lgvl = (\thrdid_c, \thrdid_n, \hthrdlocalst_c, \hthrdlocalst_n, 
                \hthrdlocalst_c, \hthrdlocalst_n, \nst)) \\
            \\[-9pt]
            \quad
            \relspecpre_{\textit{su}} \, \lgvl \define 
            I(\thrdid_c, \RFile, \hthrdlocalst_c) \sepstar 
            (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n) 
            \sepstar
            \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
            \safePrimAst{\, \primsw(\nil) \,} \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{su}} \, \lgvl \define 
            \exists \, \hthrdlocalst'. \, 
            \Env{\nst, \nil} \sepstar 
            (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n) \sepstar \\
            \hspace*{6em}
            \RelCurT{\thrdid_n}{\nst}{(\nst, \nil)}{\hthrdlocalst'} 
            \sepstar \RelRdyT{\thrdid_c}{\RFile}{\hthrdlocalst_c}
            \sepstar \safePrimAst{\, \primdone \,}
            \\
            \\[-5pt]
            \SwitchNewTask{}
            \ (\lgvl = (\thrdid_c, \thrdid_n, \hthrdlocalst_c, 
            \hthrdlocalst_n, \RFile, \nst)) \\
            \\[-9pt]
            \quad 
            \relspecpre_{\textit{sn}} \ \lgvl \define 
            \exists \, \RFile_0. \, \Env{(\RFile_0, \nil)} \sepstar 
            (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n)
            \sepstar \metricAst{1} \sepstar \\
            \hspace*{6em}
            \RelCurT{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c} \sepstar
            \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
            \safePrimAst{\, \primsw(\nil) \,} \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{sn}} \, \lgvl \define 
            \exists \, \hthrdlocalst'. \, 
            \Env{\nst, \nil} \sepstar 
            (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n) \sepstar \\
            \hspace*{6em}
            \RelCurT{\thrdid_n}{\nst}{(\nst, \nil)}{\hthrdlocalst'} 
            \sepstar \RelRdyT{\thrdid_c}{\RFile}{\hthrdlocalst_c}
            \sepstar \safePrimAst{\, \primdone \,}
            \\
            \\
            \texttt{window\_save}: \ (\lgvl = (\thrdid, \hthrdlocalst, \RFile, 
                \Wstack, \primcom, \block)) \\
            \\[-9pt]
            \quad
            \relspecpre_{\textit{ws}} \ \lgvl \define 
            (\Env{\RFile, \Wstack} \sepstar \RelStkFm{\block}{\notCare}{\notCare}
            \sepstar (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar 
            \safePrimAst{\primcom}) \, \land \, \RFile(\spreg) = (\block, 0) \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{ws}} \ \lgvl \define 
            (\Env{\RFile, \Wstack} \sepstar 
            \RelStkFm{\block}{\RFile(\localRN)}{\RFile(\inRN)}
            \sepstar (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar 
            \safePrimAst{\primcom}) \, \land \, \RFile(\spreg) = (\block, 0) \\
            \\[-5pt]
            \texttt{window\_restore}: \ (\lgvl = (\thrdid, \hthrdlocalst, \RFile, \Wstack, 
            \primcom, \block, \fm_1, \fm_2)) \\
            \\[-9pt]
            \quad
            \relspecpre_{\textit{wr}} \ \lgvl \define 
            (\Env{\RFile, \Wstack} \sepstar \RelStkFm{\block}{\fm_1}{\fm_2} 
            \sepstar (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar 
            \safePrimAst{\primcom}) \, \land \, \RFile(\spreg) = (\block, 0) \\
            \\[-9pt]
            \quad
            \relspecpost_{\textit{wr}} \ \lgvl \define 
            (\Env{\RFile\{ \localRN \rightsquigarrow \fm_1, \inRN \rightsquigarrow \fm_2 \}, \Wstack} \
            \sepstar \RelStkFm{\block}{\fm_1}{\fm_2} 
            \sepstar (\astCurCont{\thrdid}{\hthrdlocalst}) \sepstar 
            \safePrimAst{\primcom}) 
            \, \land \, \RFile(\spreg) = (\block, 0) 
        \end{array}
    \]
    \caption{Specifications of Internal Functions}
    \label{fig:Specifications of Internal Functions}
\end{figure}

Codes about saving \localRN{} and \inRN{} registers 
into stack in memory and restoring \localRN{} and 
\inRN{} registers from stack in memory are not 
implemented as functions. However, we still give 
the specifications of this part of codes shown 
as \texttt{window\_save} and \texttt{window\_restore}
in \Fig{\ref{fig:Specifications of Internal Functions}}, 
in order to allow readers to better understand 
the functionalities of this part of codes. 

We define the code heap specification $\Cspec{}$ 
below, which is the collection of specifications of 
code blocks in $\code_{\texttt{switch}}$.
\begin{equation}
    \begin{array}{lcl}
        \Cspec & \define & 
        \{
            \texttt{SwitchEntry} \leadsto (\Apre, \Apost), \,
            \texttt{reg}\_\texttt{save} \leadsto 
            (\relspecpre_{\textit{rs}}, \relspecpost_{\textit{rs}}), \,
            \texttt{reg}\_\texttt{restore} \leadsto
            (\relspecpre_{\textit{rr}}, \relspecpost_{\textit{rr}}), \\
            & & \qquad\qquad
            \SaveUsedWin{} \leadsto (\relspecpre_{\textit{su}}, \relspecpost_{\textit{su}}), \,
            \SwitchNewTask{} \leadsto (\relspecpre_{\textit{sn}}, \relspecpost_{\textit{sn}})) 
        \}
    \end{array}
    \label{a:ctxswitch-Cspec}
\end{equation}

\begin{figure}[!t]
    \[
        \small
        \begin{array}{lll}
            \multicolumn{3}{l}
                {
                    \quad \texttt{SwitchEntry}: 
                } \\
            \multicolumn{3}{l}
            {
                \color{blue}
                \{
                    \Apre(\thrdid_c, \thrdid_n, (\RFile, \Wstack), \nst, 
                        \hthrdlocalst_c, \hthrdlocalst_n)
                \}  
            } \\
            \\[-9pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \Env{\RFile, \Wstack} \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n)
                        \sepstar \metricAst{10} \sepstar \\
                        \quad 
                        \RelCurT{\thrdid_c}{\notCare}{(\RFile, \Wstack)}{\hthrdlocalst_c} 
                        \sepstar
                        \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
                        \safePrimAst{\,\primsw(\nil)\,}
                    \end{array}
                \right\}^{\color{red} \textcircled{1}}  
            } \\
            1 \quad \ \  
            & 
            \multicolumn{2}{l}
            {
                /* \text{saving the \inRN{} and \localRN{}
                registers of current window into stack frame} */
            } \\
            % \call{} \qquad \quad & \WinSave \\
            2 
            & \nop{} \\
            & \dots \\
            5
            & \call{} & \texttt{reg}\_\texttt{save} \\
            6
            & \nop{} \\
            \\[-9pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \Env{\RFile\{ \lreg{1} \rightsquigarrow \notCare \}, \Wstack} \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n)
                        \sepstar \metricAst{9} \sepstar \\
                        \quad 
                        {
                            \colorbox{yellow!80}
                            {
                                $\RelCurT{\thrdid_c}{\RFile}{(\RFile, \Wstack)}{\hthrdlocalst_c}$
                            }
                        } 
                        \sepstar
                        \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
                        \safePrimAst{\,\primsw(\nil)\,}
                    \end{array}
                \right\}^{\color{red} \textcircled{2}} 
            } \\
            \\[-9pt]
            7
            & \get & \regcwp, \greg{4} \\
            8
            & \rd{} & \regwim, \greg{7} \\
            9
            & \sett & 1, \greg{6} \\
            10 & \sll & \greg{6}, \greg{4}, \greg{4} \\
            \\[-9pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \exists \, \RFile_0. \, 
                        (\Env{\RFile_0, \Wstack} \, \land \, \wptr(\RFile_0)) \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n)
                        \sepstar \metricAst{9} \sepstar \\
                        \quad 
                        \RelCurT{\thrdid_c}{\RFile}{(\RFile, \Wstack)}{\hthrdlocalst_c}
                        \sepstar
                        \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
                        \safePrimAst{\,\primsw(\nil)\,}
                    \end{array}
                \right\}  
            } \\
            \\[-5pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \{
                    I(\thrdid_c, \RFile, \hthrdlocalst_c) \sepstar 
                    (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, \thrdid_c \neq \thrdid_n)
                    \sepstar
                    \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
                    \safePrimAst{\, \primsw(\nil) \,}
                \}
            }
            \\
            \\[-9pt]
            \multicolumn{3}{l}
                {
                    \quad \texttt{Save}\_\texttt{Usedwindow}: 
                } \\
            11 & \sll & \greg{4}, 1, \greg{5} \\
            & \dots \\
            20 & \jmp{} & \texttt{Save}\_\texttt{UsedWindow} \\
            21 & \nop{} \\
            \\[-5pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \exists \, \RFile_0. \, 
                        {
                            \colorbox{yellow!80}
                            {
                                $\Env{\RFile_0, \nil}$
                            }
                        } 
                        \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        \thrdid_c \neq \thrdid_n) \sepstar \metricAst{1} \sepstar \\
                        \quad 
                        \RelCurT{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c}
                        \sepstar
                        \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n} \sepstar 
                        \safePrimAst{\, \primsw(\nil) \,}
                    \end{array}
                \right\}^{\color{red} \textcircled{3}}
            } \\
            \\[-9pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \exists \, \RFile_0. \, 
                        \Env{\RFile_0, \nil} \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        \thrdid_c \neq \thrdid_n) \sepstar \metricAst{1} \sepstar 
                        \safePrimAst{\, \primsw(\nil) \,} \\
                        \\[-9pt] \quad \sepstar 
                        {
                            \colorbox{yellow!80}
                            {
                                $
                                \relmsto{\TaskCur}{(\thrdid_c, 0)} \sepstar
                                \RelCurTAux{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c}
                                $
                            }
                        }
                        \sepstar 
                        \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n}
                        % (
                        %     \exists \, \block_0. \, 
                        %     (\relmsto{\TaskCur}{(\thrdid_c, 0)} \sepstar 
                        %     \relcontext{\thrdid_c}{\block}{\RFile} \sepstar 
                        %     \RelStk{\block_0}{\nil}{\hWstk} \sepstar
                        %     (\astCurCont{\thrdid_c}{((\hRfile, \block, \hWstk), \pc, \npc)})) \\
                        %     \quad \ \ \, \land \, 
                        %     \RFile(\spreg) = (\block, 0) \, \land \, 
                        %     \RFile(\fpreg) = (\block_0, 0) \, \land \, 
                        %     \Rinj{\RFile}{\hRfile} \, \land \, 
                        %     \hthrdlocalst_c = 
                        %     ((\hRfile, \block, \hWstk), \pc, \npc)
                        % ) \\
                        % \\[-9pt] \sepstar
                        % (
                        %     \exists \, \block_1. \, 
                        %     (\relcontext{\thrdid_n}{\block'}{\nst} \sepstar 
                        %     \RelStk{\block_1}{\nil}{\hWstk'} \sepstar 
                        %     (\astRdyCont{\thrdid_n}{((\hRfile', \block', \hWstk'), \pc', \npc')})
                        %     ) \\
                        %     \quad \ \ \, \land \, 
                        %     \nst(\spreg) = (\block', 0) \, \land \, 
                        %     \nst(\fpreg) = (\block_1, 0) \, \land \, 
                        %     \Rinj{\nst}{\hRfile'} \, \land \, 
                        %     \hthrdlocalst_n = 
                        %     ((\hRfile', \block', \hWstk'), \pc', \npc')
                        % )
                    \end{array}
                \right\}
            } \\
            \\[-9pt]
            \multicolumn{3}{l}
                {
                    \quad \texttt{Switch}\_\texttt{NewContext}: 
                } \\
            22 & \sett & \TaskCur, \lreg{0} \\
            23 & \sett & \TaskNew, \lreg{1} \\
            & \dots \\ 
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \colorbox{yellow!80}
                        {
                            $\Env{\nst, \nil}$
                        } \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        \thrdid_c \neq \thrdid_n) \sepstar 
                        \safePrimAst{\, \primsw(\nil) \,} \\
                        \\[-9pt] \quad \sepstar
                        \relmsto{\TaskCur}{(\thrdid_n, 0)} \sepstar 
                        \colorbox{gray!60}
                        {
                            $\RelCurTAux{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c}$
                        } 
                        \sepstar
                        % \RelCur{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c} \sepstar
                        \colorbox{green!60}
                        {
                            $\RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst_n}$
                        }  
                        % \colorbox{yellow!80}
                        % {
                        %     $\Env{\nst, \nil}$
                        % } \sepstar 
                        % (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        % \thrdid_c \neq \thrdid_n) \sepstar 
                        % \safePrimAst{\, \primsw(\nil) \,} \\
                        % \\[-9pt] \sepstar
                        % (
                        %     \exists \, \block_0. \, 
                        %     (
                        %         \colorbox{yellow!80}
                        %         {
                        %             $\relmsto{\TaskCur}{(\thrdid_n, 0)}$
                        %         } 
                        %         \sepstar 
                        %     \relcontext{\thrdid_c}{\block}{\RFile} \sepstar 
                        %     \RelStk{\block_0}{\nil}{\hWstk} \sepstar
                        %     (\astCurCont{\thrdid_c}{((\hRfile, \block, \hWstk), \pc, \npc)})) \\
                        %     \quad \ \ \, \land \, 
                        %     \RFile(\spreg) = (\block, 0) \, \land \, 
                        %     \RFile(\fpreg) = (\block_0, 0) \, \land \, 
                        %     \Rinj{\RFile}{\hRfile} \, \land \, 
                        %     \hthrdlocalst_c = 
                        %     ((\hRfile, \block, \hWstk), \pc, \npc)
                        % ) \\
                        % \\[-9pt] \sepstar
                        % (
                        %     \exists \, \block_1. \, 
                        %     (\relcontext{\thrdid_n}{\block'}{\nst} \sepstar 
                        %     \RelStk{\block_1}{\nil}{\hWstk'} \sepstar 
                        %     (\astCurCont{\thrdid_n}{((\hRfile', \block', \hWstk'), \pc', \npc')})
                        %     ) \\
                        %     \quad \ \ \, \land \, 
                        %     \nst(\spreg) = (\block', 0) \, \land \, 
                        %     \nst(\fpreg) = (\block_1, 0) \, \land \, 
                        %     \Rinj{\nst}{\hRfile'} \, \land \, 
                        %     \hthrdlocalst_n = 
                        %     ((\hRfile', \block', \hWstk'), \pc', \npc')
                        % )
                    \end{array}
                \right\}^{\color{red} \textcircled{4}}
            } \\
            \\[-9pt]
            &
                \begin{rotate}{90}
                    \color{red}
                    $\Lleftarrow$
                \end{rotate}
            & \\[-5pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \left\{
                    \begin{array}{l}
                        \Env{\nst, \nil} \sepstar 
                        (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        \thrdid_c \neq \thrdid_n) \sepstar 
                        \safePrimAst{\, \primdone \,} \\
                        \\[-9pt] \quad \sepstar
                        \relmsto{\TaskCur}{(\thrdid_n, 0)} \sepstar 
                        \colorbox{green!60}
                        {
                            $\RelRdyT{\thrdid_c}{\RFile}{\hthrdlocalst_c}$
                        } 
                        \sepstar
                        % \RelCur{\thrdid_c}{\RFile}{(\RFile, \nil)}{\hthrdlocalst_c} \sepstar
                        \colorbox{gray!60}
                        {
                            $(\exists \, \hthrdlocalst'. \, 
                                \RelRdyT{\thrdid_n}{\nst}{\hthrdlocalst'})$
                        }  
                        % \Env{\nst, \nil}\sepstar 
                        % (\relmsto{\TaskNew}{(\thrdid_n, 0)} \, \land \, 
                        % \thrdid_c \neq \thrdid_n) \sepstar 
                        % \safePrimAst{\, \primsw(\nil) \,} \\
                        % \\[-9pt] \sepstar
                        % (
                        %     \exists \, \block_0. \, 
                        %     (
                        %         \colorbox{green!60}
                        %         {
                        %             $\relmsto{\TaskCur}{(\thrdid_n, 0)}$
                        %         } 
                        %         \sepstar 
                        %     \colorbox{yellow!80}
                        %     {
                        %         $
                        %         \relcontext{\thrdid_c}{\block}{\RFile} \sepstar 
                        %         \RelStk{\block_0}{\nil}{\hWstk} \sepstar    
                        %         (\astCurCont{\thrdid_n}{((\hRfile', \block', \hWstk'), 
                        %         \lab{}', \lab{}'\!+\!4))})
                        %         $
                        %     } \\
                        %     \quad \ \ \, 
                        %     \colorbox{yellow!80}
                        %     {
                        %         $
                        %         \land \, 
                        %         \RFile(\spreg) = (\block, 0) \, \land \, 
                        %         \RFile(\fpreg) = (\block_0, 0) \, \land \, 
                        %         \Rinj{\RFile}{\hRfile} \, \land \, 
                        %         \hthrdlocalst_c = 
                        %         ((\hRfile, \block, \hWstk), \pc, \npc)
                        %         $
                        %     }
                        % ) \\
                        % \\[-9pt] \sepstar
                        % (
                        %     \colorbox{green!60}
                        %     {
                        %         $\exists \, \block_1. \, 
                        %         (\relcontext{\thrdid_n}{\block'}{\nst} \sepstar 
                        %         \RelStk{\block_1}{\nil}{\hWstk'} \sepstar 
                        %         (\astCurCont{\thrdid_n}{((\hRfile', \block', \hWstk'), \pc', \npc')}))$
                        %     }
                        %     \\
                        %     \quad \ \ \, 
                        %     \colorbox{green!60}
                        %     {
                        %         $\land \, 
                        %         \nst(\spreg) = (\block', 0) \, \land \, 
                        %         \nst(\fpreg) = (\block_1, 0) \, \land \, 
                        %         \Rinj{\nst}{\hRfile'} \, \land \, 
                        %         \hthrdlocalst_n = 
                        %         ((\hRfile', \block', \hWstk'), \pc', \npc')$
                        %     }
                        % )
                    \end{array}
                \right\}^{\color{red} \textcircled{5}}
            } \\
            \\[-9pt]
            30 & \retl{} \\
            31 & \nop{} \\
            \\[-9pt]
            \multicolumn{3}{l}
            {
                \color{blue}
                \{
                    \Apost(\thrdid_c, \thrdid_n, (\RFile, \Wstack), \hthrdlocalst_c, 
                    \hthrdlocalst_n)    
                \}
            }
        \end{array}
    \]
    \caption{Proof Sketch of the Context Switch Routine}
    \label{fig:Proof Sketch of the Context Switch Routine}
    \vspace*{-0.5em}
\end{figure}

\begin{lemma}
    \em
    \label{lemma:wfcdhp}
    $\wfcdhp{\code_{\texttt{switch}}}{\Cspec{}}$
\end{lemma}
\begin{proof}
    The code heap specification $\Cspec{}$ have been 
    defined in (\ref{a:ctxswitch-Cspec}). We unfold 
    $\wfcdhp{\code_{\texttt{switch}}}{\Cspec{}}$ 
    according to its definition 
    (in \Fig{\ref{fig:Selected Inference Rules for Refinement Verification}}). 
    And we need to prove that, for any $\lgvl_1$, 
    $\lgvl_2$, $\lgvl_3$, 
    $\lgvl_4$ and $\lgvl_5$, the following hold: 
    \begin{align}
        & \wfcblk{\Apre \ \lgvl_1}{\Apost \ \lgvl_1}
            {\texttt{SwitchEntry}}
            {\code_{\texttt{switch}}[\texttt{SwitchEntry}]}
            \label{a:ctxswitch-wfse} \\
        & \wfcblk{\relspecpre_{\textit{rs}} \ \lgvl_2}
            {\relspecpost_{\textit{rs}} \ \lgvl_2}
            {\texttt{reg}\_\texttt{save}}
            {\code_{\texttt{switch}}[\texttt{reg}\_\texttt{save}]} 
            \label{a:ctxswitch-wfrs} \\
        & \wfcblk{\relspecpre_{\textit{rr}} \ \lgvl_3}
            {\relspecpost_{\textit{rr}}\ \lgvl_3}
            {\texttt{reg}\_\texttt{restore}}
            {\code_{\texttt{switch}}[\texttt{reg}\_\texttt{restore}]} 
            \label{a:ctxswitch-wfrr} \\
        & \wfcblk{\relspecpre_{\textit{su}} \ \lgvl_4}
            {\relspecpost_{\textit{su}} \ \lgvl_4}
            {\SaveUsedWin}{\code_{\texttt{switch}}[\SaveUsedWin]} 
            \label{a:ctxswitch-wfsu} \\
        & \wfcblk{\relspecpre_{\textit{sn}} \ \lgvl_5}
            {\relspecpost_{\textit{sn}} \ \lgvl_5}
            {\SwitchNewTask}
            {\code_{\texttt{switch}}[\SwitchNewTask]}
            \label{a:ctxswitch-wfsn}
    \end{align} 

    We need to prove that each code block 
    is well-defined ((\ref{a:ctxswitch-wfse}) - 
    (\ref{a:ctxswitch-wfsn})). Here, we do not 
    show the details about verifying each code block 
    respectively. We just give a proof sketch 
    of the verifying of the main function, which can be found in 
    \Fig{\ref{fig:Proof Sketch of the Context Switch Routine}}.

    % The code heap specification $\Cspec_i$ is the collection of 
    % the specifications of each code block shown in 
    % \Fig{\ref{fig:Specifications of Internal Functions}}, and 
    % the verification of internal functions has no differences with 
    % the original proof of context switch routine introduced in 
    % \Sec{\ref{sec:ctxswitch}}. So, here we just give a proof sketch 
    % of the verifying of the main function, which can be found in 
    % \Fig{\ref{fig:Proof Sketch of the Context Switch Routine}}. 

    Supposing in the inital state (described as assertion marked 
    {\color{red} \textcircled{1}}), 
    the register file is $\RFile$, 
    and the part of the frame list, which is waitting for saving into 
    the stack in memory, is $\Wstack$. The code segment 
    from line 1 to line 6 is responsible for saving the register file  
    $\RFile$ into current task's TCB, and we achieve assertion 
    marked {\color{red} \textcircled{2}}. 

    The codes from line 7 to 21 saves the prefix $\Wstack$ of the 
    frame list into current task's stack in memory. After execution 
    of this segment. The part of the frame list, waitting for storing 
    into memory, becomes empty (\nil). And the assertion marked
    {\color{red} \textcircled{3}} holds.  

    Then, we prove the code block \texttt{switch\_new\_task}, which 
    restores the context $\nst$ of the new task $\thrdid_n$. After 
    executing the codes from line 22 to line 29, the context $\nst$ of 
    the new task $\thrdid_n$ is restored (shown as $\Env{(\nst, \nil)}$), 
    and the assertion marked {\color{red} \textcircled{4}} holds. 

    Finally, we apply \textbf{ABSCSQ} rule, shown in 
    \Fig{\ref{fig:Selected Inference Rules for Refinement Verification}}, 
    to execute the abstract assembly primitive $\primsw{}$, and the 
    assertion marked {\color{red} \textcircled{5}} holds. 
    By applying \textbf{RETL} rule shown in 
    \Fig{\ref{fig:Selected Inference Rules for Refinement Verification}}, 
    we finish the proof. 
\end{proof}

\begin{theorem}
    \em
    $\wfprim{\Cspec}{\code_{\texttt{switch}}}
        {\{\texttt{SwitchEntry}\rightsquigarrow \primsw\}}$. 
\end{theorem}
\begin{proof}
    We unfold 
    $\wfprim{\Cspec}{\code_{\texttt{switch}}}
        {\{ \texttt{SwitchEntry}\leadsto \primsw \}}$ 
    according to its definition 
    (in \Fig{\ref{fig:Selected Inference Rules for Refinement Verification}}) 
    and we need to prove the following hold:
    \begin{itemize}
        \item $\wfcdhp{\asmimp}{\Cspec{}}$. \quad 
            The correctness proof of this subgoal can be done by 
            apply Lemma~\ref{lemma:wfcdhp}. 
        \item $\wdSpec{\Apre}{\apost}{\primsw}$. \quad
            The correctness proof of this subgoal can be done by 
            apply Lemma~\ref{lemma:wdspec}.
    \end{itemize}
\end{proof}

\begin{figure*}[!t]
    \subfigure[Save \localRN{} and \outRN{} into memory]
    {
        \begin{minipage}[b]{0.5\textwidth}
        \[
            \begin{array}{ll}
                \st & \lreg{0}, \ [\spreg + \texttt{L0\_OFFSET}] \\
                \st & \lreg{1}, \ [\spreg + \texttt{L1\_OFFSET}] \\
                \st & \lreg{2}, \ [\spreg + \texttt{L2\_OFFSET}] \\
                \st & \lreg{3}, \ [\spreg + \texttt{L3\_OFFSET}] \\
                \st & \lreg{4}, \ [\spreg + \texttt{L4\_OFFSET}] \\
                \st & \lreg{5}, \ [\spreg + \texttt{L5\_OFFSET}] \\
                \st & \lreg{6}, \ [\spreg + \texttt{L6\_OFFSET}] \\
                \st & \lreg{7}, \ [\spreg + \texttt{L7\_OFFSET}] \\
                \st & \ireg{0}, \ [\spreg + \texttt{I0\_OFFSET}] \\
                \st & \ireg{1}, \ [\spreg + \texttt{I1\_OFFSET}] \\
                \st & \ireg{2}, \ [\spreg + \texttt{I2\_OFFSET}] \\
                \st & \ireg{3}, \ [\spreg + \texttt{I3\_OFFSET}] \\
                \st & \ireg{4}, \ [\spreg + \texttt{I4\_OFFSET}] \\
                \st & \ireg{5}, \ [\spreg + \texttt{I5\_OFFSET}] \\
                \st & \ireg{6}, \ [\spreg + \texttt{I6\_OFFSET}] \\
                \st & \ireg{7}, \ [\spreg + \texttt{I7\_OFFSET}]
            \end{array}
        \]
        \end{minipage}
    }
    \subfigure[Restore \localRN{} and \inRN{} from memory]{
        \begin{minipage}[b]{0.5\textwidth}
        \[
            \begin{array}{ll}
                \ld & [\spreg + \texttt{L0\_OFFSET}], \ \lreg{0} \\
                \ld & [\spreg + \texttt{L1\_OFFSET}], \ \lreg{1} \\
                \ld & [\spreg + \texttt{L2\_OFFSET}], \ \lreg{2} \\
                \ld & [\spreg + \texttt{L3\_OFFSET}], \ \lreg{3} \\
                \ld & [\spreg + \texttt{L4\_OFFSET}], \ \lreg{4} \\
                \ld & [\spreg + \texttt{L5\_OFFSET}], \ \lreg{5} \\
                \ld & [\spreg + \texttt{L6\_OFFSET}], \ \lreg{6} \\
                \ld & [\spreg + \texttt{L7\_OFFSET}], \ \lreg{7} \\
                \ld & [\spreg + \texttt{I0\_OFFSET}], \ \ireg{0} \\
                \ld & [\spreg + \texttt{I1\_OFFSET}], \ \ireg{1} \\
                \ld & [\spreg + \texttt{I2\_OFFSET}], \ \ireg{2} \\
                \ld & [\spreg + \texttt{I3\_OFFSET}], \ \ireg{3} \\
                \ld & [\spreg + \texttt{I4\_OFFSET}], \ \ireg{4} \\
                \ld & [\spreg + \texttt{I5\_OFFSET}], \ \ireg{5} \\
                \ld & [\spreg + \texttt{I6\_OFFSET}], \ \ireg{6} \\
                \ld & [\spreg + \texttt{I7\_OFFSET}], \ \ireg{7}
            \end{array}
        \]
        \end{minipage}
    }
    \caption{Code for saving and restoring \localRN{} and \inRN{} registers}
    \label{fig:code for saving and restoring local and in}
\end{figure*}
